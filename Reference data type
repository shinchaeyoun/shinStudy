12. Primitive/Reference data types
프리미티브/레퍼런스 데이터 타입

그냥 문자와 숫자는 프리미티브 데이터 타입
var 변수 = 'dddd';
- 변수에 값이 그대로 저장됨
- array
var array = [1,2,3];

array, Object는 변수에 값이 저장이 안된다.
변수에 reference가 저장된다. //[1,2,3]이 저기에 있다는 화살표

reference data type
var obj = {name : 'kim'};

--------------
reference data type 다루기 : 복사
레퍼런스 데이터 타입은 이름1에 데이터가 전달밖는 것

--------
Primitive data type 다루기 : 복사

var name1 = 'Kim';
var name2 = name1; // copy

name2를 출력하면? 'kim'
name1를 출력하면? 'kim'

name1 = 'park';

console.log('name1',name1); // 'kim'
console.log('name2',name2); // 'park'

--
reference data type 다루기 : 복사

var name1 = { name : 'Kim' };
var name2 = name1;

name1.name = 'park'

console.log(name1); // 'park'
console.log(name2); // 'park'


오브젝트나 어레이는 레퍼런스 데이터 타입이라
변수에 저장되는게 아니라 pc 메모리의 화살표가 저장 됨
var name1 = name:김 저기 저장됨; 이라는 뜻

var name1 = { name : 'Kim' };
var name2 = name1; // 이름2에 이름1의 화살표를 복사한 것

그래서 array, object 함부로 복사하면 클남~
그럼 복사하고 싶으면 어케?
- object 복사 기계 --다음에

var name1 = { name : 'Kim' };
var name2 = { name : 'park' };

--
reference data type 다루기 예시2

var name1 = { name : 'Kim' };
var name2 = { name : 'Kim' };

name1 == name2; // false
오브젝트가 저장된게 아니라 화살표를 저장한거라 false
각각 다른 자료를 가르키는 화살표라서~

오브젝트를 변경해주는 함수
function 변경 (obj){
  obj.name = 'Park';
};
변경(name1); // Park

// 오브젝트를 재할당해주는 함수
function 변경 (obj){
  obj = {name: 'park'}
};
변경(name1); // Park
- 실패.. 안바뀜
레퍼런스와 파라미터의 합작이라 바뀌지 않음
파라미터는 변수생성&할당과 똑같음
변경 (var obj = 이름1); 과 동일한 것

이름1에 저장된 것은 화살표
똑같은 위치를 가르키는 화살표

새로운 오브젝트 할당
var name1 = {name : 'kim'};
function 변경(obj) {
  obj = { name : 'park' }
};
변경(name1);

파라미터 변수에 ={} 해봤자 원래 name1 오브젝트는 변화가 없다.

============
13. constructor
Object 생성기계인 constructor
 
constructor 문법의 용도
- Object를 마구 복사하고 싶을 때 사용
- 비슷한 object 여러개 만들 때

예시: 학생 출석부를 만들어보자

var 학생1 = { name: 'Kim', age: 15 }

// 대문자로 적음 ex)Student
function 기계(){
  this.name = 'Kim';
  this.age = 15;
};

new 기계();

constructor 안에서 쓰는 this는 새로생성되는 object를 뜻함
새로생성되는 오브젝트들의 에이지에는 15를 넣어주세요 라는 뜻
새로생성되는 오브젝트에 값 부여가능

var 학생1 = new 기계();
var 학생2 = new 기계();
console.log(학생1, 학생2)
반복문 사용 가능. 오브젝트 안에 내용이 많을 경우 편리

Q.기계로 생성과는 모든 학생 오브젝트에 sayHi()함수 추가

var 학생1 = {
  name: 'Kim',
  age : 15,
  sayHi: function (){
    console.log('안녕하세요 '+this.name+'입니다.')
  }
};

function 기계(){
  this.name = 'Kim';
  this.age = 15;
  this.sayHi = function(){
    console.log('안녕하세요 '+this.name+'입니다.')
  };
};

학생1.sayHi(); // 안녕하세요 Kim입니다.
학생2.sayHi(); // 안녕하세요 Kim입니다.

문자나 함수나 별걸 다 넣어서 오브젝트 생성 기계를 만들 수 있음

Q. 기계로 학생을 뽑을 때 name을 다르게 설정해주고 싶어요

function 기계(이름){
  this.name = 이름;
  this.age = 15;
  this.sayHi = function(){
    console.log('안녕하세요 '+this.name+'입니다.')
  };
};

기계('lee');

var 학생1 = new 기계('Park')
var 학생2 = new 기계('Lee')


 this: 기계에서 새로생성되는 Object (instance)
 기계: object생성기계(constructor, 생성자)

=====
연습문제
쇼핑몰에 쓸 상품데이터를 오브젝트로 여러개 만들고 싶습니다. 

Q1. 위처럼 생긴 상품오브젝트들을 뽑아낼 수 있는 constructor를 제작해보세요.
그리고 실제 상품 두개를 뽑아보십시오.

function 기계 (name, price){
  this.name = name;
  this.price = price;
};

var product1 = new 기계('shirts', 50000)
var product2 = new 기계('pants', 60000)

console.log(product1,product2);

Q2. 상품마다 부가세() 라는 내부 함수를 실행하면 콘솔창에 상품가격 * 10% 만큼의 부가세금액이 출력되도록 하고 싶으면
constructor를 어떻게 수정해야할까요?

function 기계 (name, price){
  this.name = name;
  this.price = price;
  this.부가세 = function (){
    return price / 10
  }
};

var product1 = new 기계('shirts', 50000)
var product2 = new 기계('pants', 60000)

console.log(product1.부가세());


function Product(상품명, 가격){
  this.name = 상품명;
  this.price = 가격;
  this.부가세 = function(){
    console.log(this.price * 0.1)
  }
}

var product1 = new Product('shirts', 50000);
var product2 = new Product('pants', 60000);

==================
14. prototype

constructor = 상속이라고 함
상속을 받은 것임 기계로부터. 기계가 가지고 있는 속성들을 물려받음

상속을 구현할 수 있는 또 하나의 문법 prototype
prototype은 유전자
prototype에 값을 추가하면 모든 자식들이 물려받기 가능

기계(constructor)를 만들면 prototype이라는 공간이 자동으로 생김
기계는 일종의 오브젝트라 console창에 .prototype


function 기계(이름){
  this.name = 이름;
  this.age = 15;
  this.sayHi = function(){
    console.log('안녕하세요 '+this.name+'입니다.')
  };
};

기계.prototype.gender = 'male'; // 키와 벨류 추가

var 학생1 = new 기계('Park');

----
prototype의 동작원리
:내장함수는 어떻게 동작하는가

내가 만든 array에 arr.toString() 이렇게 붙일 수 있는 이유는 

내가 만든 array의 부모 유전자가 toString()을 가지고 있기 때문입니다. (혹은 부모의 부모요)

Q. 그럼 prototype으로 상속시키는거랑 constructor로 상속시키는거랑 차이가 뭐죠?

A. 자식들이 값을 직접 소유하게 만들고 싶으면 constructor로 상속시키시면 되고
부모만 가지고 있고 그걸 참조해서 쓰게 만들고 싶으면 prototype으로 상속시키면 되겠쥬?
보통은 그래서 상속할 수 있는 함수 같은 것들은 prototype으로 많이 만들어놓습니다. 

==================
15. prototype2

1. prototype은 함수에만 몰래 생성됨
2. 내 부모 유전자(부모의 prototype)를 검사하고 싶다면 __proto__
3. __proto__를 이용해 부모 강제 등록하기
4. 콘솔창에서 알려주는 prototype chain


3. -> 프로토는 이런 역할을 한다 예시
var 부모 = {name: 'kim'};
var 자식 = {};
자식.__proto__ = 부모;
자식.name;

===============
constructor, prototype 연습문제 4개

0. 오브젝트 자료 여러개를 만들고 싶습니다.
var 학생1 = { name : 'Kim', age : 20 }
var 학생2 = { name : 'Park', age : 21 }
var 학생3 = { name : 'Lee', age : 22 }

constructor문법을 사용해서 위의 오브젝트와 똑같은 오브젝트 3개를 한번 뽑아보십시오. 

+ 여기에 학생1.sayHi()라고 사용하면 "안녕 나는 Kim이야" 라는 글자가 콘솔창에 나오도록 sayHi()라는 함수도 constructor 안에 추가해보세요.

==
function Student ($name, $age){
  this.name = $name;
  this.age = $age;
  this.sayHi = function (){
    console.log('hi my name is ' + this.name);
  }
};

var 학생1 = new Student('Kim',20);
var 학생2 = new Student('Park', 21);
var 학생3 = new Student('Lee', 22);

학생1.sayHi();


1. 다음 코드의 출력 결과는 무엇일까요?
function Parent(){
  this.name = 'Kim';
};
var a = new Parent();

a.__proto__.name = 'Park';
console.log(a.name)

==해설
첫 4줄에 의해서 a = { name : 'Kim' } 이 되고 
a.__proto__.name = 'Park'; 이건 부모 prototype에 { name : 'Park' } 이걸 추가하라는 뜻입니다.
그럼 이제 a.name 이라고 사용했을 때 
내가 직접 가지고 있는 { name : 'Kim' } 이걸 우선 출력해줍니다.


2. 함수가 안들어가요 엉엉

위에 0번 문제에서 Student라는 부모에 sayHi라는 함수를 하나 추가하라고 했죠?
그래서 sayHi()라고 사용하면 "안녕 나는 ~~이야" 라고 내 이름을 출력해주는 함수를 prototype에 추가했습니다. 
하단처럼 만들었는데 의도한 대로 이름이 출력되지 않고 있습니다. 
원인은 무엇일까요? 

function Student(이름, 나이){
  this.name = 이름;
  this.age = 나이;
}
Student.prototype.sayHi = () => {
    console.log('안녕 나는 ' + this.name + '이야');
  }
var 학생1 = new Student('Kim', 20);

학생1.sayHi(); //왜 이 코드가 제대로 안나오죠?

== 해설
sayHi 함수를 만들 때 arrow function을 사용해서 내부에 있던 this라는 값이 이상해짐.
sayHi 함수를 출력하면 this의 값은 window가 나옴.

함수안에서 this 키워드의 뜻은 매번 재정의됨.
object안에 들어있는 함수안에 있는 this는 함수를 부른 object가 됨.
arrow function의 경우 함수 안에서 this 뜻이 재정의되지 않고 바깥에 있던 this를 사용한다.

var 오브젝트 = {
  sayHi: () => { console.log(this) }
}
그래서 위 코드의 this는 window가 출력된다.


3. 모든 array에 적용할 수 있는 함수를 직접 새로 만들려면 어떻게 해야할까요?
모든 array에 붙일 수 있는,
array 내에 있는 3이라는 값을 제거해주는 유용한 함수를 하나 만들고 싶습니다. 

var arr = [1,2,3,4];
arr.remove3();

console.log(arr); //[1,2]

이렇게 array뒤에 붙이기만 하면 array 내의 3이라는 모든 숫자 자료들이 삭제됩니다. 
멋있게 이름은 remove3() 이라고 하겠습니다. 
remove3()함수는 어떻게, 어디에 만들어야 모든 array에 쓸 수 있을까요?

== 해설
Array.prototype.remove3 = function(){
  for(var i = 0; i < this.length; i++){
    if(this[i] === 3){
      this.splice(i,1);
    }
  }
}
var arr = [1,2,3,4];
arr.remove3();

console.log(arr);

모든 array 자료형은 부모가 Array로부터 new Array() 이런 식으로 만들어지기 때문에 Array라는 부모의 prototype에 있는 함수를 자유롭게 가져다 쓸 수 있다.

그래서 Array의 prototype에 remove3라는 함수를 추가해줘야한다.


===============
16. ES5 : Object.create

상속기능을 구현하는 다른 방법

prototype
function 기계(){}; 옛날문법임

Object.create(); ES5문법

// Object.create(프로토타입object);

var 부모 = { name: 'Kim', age: 50 };

var 자식 = Object.create(부모);

  console.log(자식); // {}
  console.log(자식.name); // Kim
  console.log(자식.age); // 50

  (1) 자식이 name을 직접 가지고 있는지? x
  (2) 부모에 name이 있는지? o

자식.age = 20;

var 손자 = Object.create(자식);
손자.name; // Kim
손자.age; // 20

- 함수 또한 넣을 수 있음

=================
17. ES6:class

constructor 만드는 신문법
class 부모 {
  constructor(){
    this.name = 'Kim';
  }
}